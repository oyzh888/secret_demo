import pandas as pd\nimport numpy as np\nfrom typing import Dict, List, Any\nfrom datamodel import OrderDepth, TradingState, Order, ConversionObservation\n\n# Aggressive Trend Following Parameters\nPARAMS = {\n    # Base parameters\n    \'position_limit\': 75,  # Position limit\n    \'conversion_limit\': 10,  # Conversion limit (unused)\n    \n    # Trend following parameters\n    \'ma_short_window\': 5,   # Very short-term moving average\n    \'ma_long_window\': 15,  # Short-term moving average\n    \'crossover_threshold\': 0.1, # Minimal difference for crossover signal\n    \n    # Trading parameters\n    \'max_trade_quantity\': 40,  # Very aggressive trade quantity\n    \'max_spread_ratio\': 0.005, # Max relative spread to allow trading (0.5%)\n}\n\nclass Trader:\n    def __init__(self):\n        # Initialize parameters\n        self.position_limit = PARAMS[\'position_limit\']\n        \n        # Trend parameters\n        self.ma_short_window = PARAMS[\'ma_short_window\']\n        self.ma_long_window = PARAMS[\'ma_long_window\']\n        self.crossover_threshold = PARAMS[\'crossover_threshold\']\n        \n        # Trading parameters\n        self.max_trade_quantity = PARAMS[\'max_trade_quantity\']\n        self.max_spread_ratio = PARAMS[\'max_spread_ratio\']\n\n        # Historical data\n        self.price_history = [] # Stores mid-prices\n        self.ma_short_history = []\n        self.ma_long_history = []\n        \n        # State\n        self.timestamp = 0\n\n    def calculate_ma(self, prices: List[float], window: int) -> float:\n        \"\"\"Calculate the moving average for a given window.\"\"\"\n        if len(prices) < window:\n            return None # Not enough data\n        return np.mean(prices[-window:])\n\n    def run(self, state: TradingState) -> tuple[Dict[str, List[Order]], int, Any]:\n        self.timestamp = state.timestamp\n        result = {}\n        conversions = 0\n        traderData = \"\"\n        product = \"MAGNIFICENT_MACARONS\"\n\n        if product not in state.order_depths:\n            return result, conversions, traderData\n            \n        order_depth = state.order_depths[product]\n        current_position = state.position.get(product, 0)\n        \n        if not order_depth.buy_orders or not order_depth.sell_orders:\n            # Need market prices to calculate MAs and trade\n            return result, conversions, traderData\n            \n        best_bid = max(order_depth.buy_orders.keys())\n        best_ask = min(order_depth.sell_orders.keys())\n        mid_price = (best_bid + best_ask) / 2\n        spread = best_ask - best_bid\n        relative_spread = spread / mid_price if mid_price > 0 else 0\n\n        # Update price history\n        self.price_history.append(mid_price)\n        if len(self.price_history) > self.ma_long_window + 2: # Keep history manageable\n            self.price_history.pop(0)\n\n        # Calculate MAs\n        ma_short = self.calculate_ma(self.price_history, self.ma_short_window)\n        ma_long = self.calculate_ma(self.price_history, self.ma_long_window)\n        \n        # Store MA history\n        if ma_short is not None: self.ma_short_history.append(ma_short)\n        if ma_long is not None: self.ma_long_history.append(ma_long)\n        if len(self.ma_short_history) > 2: self.ma_short_history.pop(0)\n        if len(self.ma_long_history) > 2: self.ma_long_history.pop(0)\n        \n        orders = []\n        \n        # Check conditions for trading\n        if ma_short is None or ma_long is None or len(self.ma_short_history) < 2 or len(self.ma_long_history) < 2:\n            # Not enough data for crossover signal\n            return result, conversions, traderData\n            \n        # Check if spread is too wide\n        if relative_spread > self.max_spread_ratio:\n            print(f\"SPREAD TOO WIDE ({relative_spread:.4f} > {self.max_spread_ratio}). Holding orders.\")\n             # If spread is wide, maybe close positions?\n             # For now, just don\'t open new ones aggressively.\n            if current_position > 0:\n                # Consider closing long if trend reverses? (MA short crosses below long)\n                if self.ma_short_history[-1] < self.ma_long_history[-1] and self.ma_short_history[-2] >= self.ma_long_history[-2]:\n                    orders.append(Order(product, best_bid, -current_position)) # Close entire position\n                    print(f\"TREND CLOSE LONG due to wide spread and MA cross down.\")\n            elif current_position < 0:\n                # Consider closing short if trend reverses? (MA short crosses above long)\n                if self.ma_short_history[-1] > self.ma_long_history[-1] and self.ma_short_history[-2] <= self.ma_long_history[-2]:\n                     orders.append(Order(product, best_ask, -current_position)) # Close entire position\n                     print(f\"TREND CLOSE SHORT due to wide spread and MA cross up.\")\n            result[product] = orders\n            return result, conversions, traderData\n\n        # --- Aggressive Trend Following Logic ---\n        available_buy = self.position_limit - current_position\n        available_sell = self.position_limit + current_position\n        \n        # Check for Bullish Crossover (Short MA crosses above Long MA)\n        crossed_up = self.ma_short_history[-1] > self.ma_long_history[-1] + self.crossover_threshold and \n                     self.ma_short_history[-2] <= self.ma_long_history[-2]\n                     \n        # Check for Bearish Crossover (Short MA crosses below Long MA)\n        crossed_down = self.ma_short_history[-1] < self.ma_long_history[-1] - self.crossover_threshold and \
                       self.ma_short_history[-2] >= self.ma_long_history[-2]\n\n        if crossed_up:\n             # Close any existing short position first\n             if current_position < 0:\n                 print(f\"TREND REVERSAL: Closing short position {-current_position} due to bullish crossover.\")\n                 orders.append(Order(product, best_ask, -current_position))\n                 available_buy += abs(current_position) # Update available capital\n                 current_position = 0 # Reset position after closing\n                 \n             # Open aggressive long position\n             if available_buy > 0:\n                 buy_quantity = min(available_buy, self.max_trade_quantity)\n                 buy_price = best_ask # Aggressively take the ask\n                 print(f\"TREND BUY SIGNAL: MA{self.ma_short_window} crossed above MA{self.ma_long_window}. Placing BUY order for {buy_quantity} at {buy_price}\")\n                 orders.append(Order(product, buy_price, buy_quantity))\n\n        elif crossed_down:\n             # Close any existing long position first\n             if current_position > 0:\n                 print(f\"TREND REVERSAL: Closing long position {current_position} due to bearish crossover.\")\n                 orders.append(Order(product, best_bid, -current_position))\n                 available_sell += current_position # Update available capital\n                 current_position = 0 # Reset position after closing\n                 \n             # Open aggressive short position\n             if available_sell > 0:\n                 sell_quantity = min(available_sell, self.max_trade_quantity)\n                 sell_price = best_bid # Aggressively hit the bid\n                 print(f\"TREND SELL SIGNAL: MA{self.ma_short_window} crossed below MA{self.ma_long_window}. Placing SELL order for {sell_quantity} at {sell_price}\")\n                 orders.append(Order(product, sell_price, -sell_quantity))\n                 \n        # Optional: Add logic to hold position if trend continues (MA short still above/below MA long)?\n        # Current logic only trades on the crossover event.\n\n        result[product] = orders\n        return result, conversions, traderData 